---
title: Migration
description: Migration guide to SST v3.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

This guide will help you migrate from SST v2 to v3. Treat these are recommendations. The exact migration plan will be different from team to team depending on the resources in your app, and sensitivity of down time.


---

## Before You Begin

1. Set the removal policy to `retain` in the v2 app for production stages. This ensures resources don't get accidentally removed.
1. Make code changes in a new branch.

---

### Major changes

- `sst dev` multiplexer
- Resource binding is called linking, and done via `Resource.`
- default function props vs $transform
- No `sst build`
- secrets not in SSM
  - No top-level await for secrets
- not stacks
- components are availably globally, no imports

- Unsupported
  - If you are using the `Job`, `Auth`, `EventBus`, `Script`, `RDS` with MySQL engine, or `Function` with non-Node.js runtime in your SST v2 app, do not migrate yet. These constructs will be supported in v3 soon.
  - Client handlers, hooks

### Initialize v3 App

1. Run `npm update sst` to update SST to v3
2. Run `npx sst version` to ensure v3 is installed
3. Run `mv sst.config.ts sst.config.ts.bk` to backup the config
4. Run `npx sst init` to initialize an v3 app. Make sure to use the same app name.
5. Configure removal policy.

    Similar to `setDefaultRemovalPolicy` in v2, you can configure the removal policy in `sst.config.ts` in v3. By default, v3 has removal policy set to `retain` for the `production` stage, and `remove` for other stages.
    ```ts title="sst.config.ts"
    app(input) {
      return {
        name: "playground",
        removal: input?.stage === "production" ? "retain" : "remove",
      };
    },
    ```
6. Run `npx sst deploy` to deploy an empty app to ensure the app is configured correctly.
7. In your root `package.json`, and that in your monorepo packages, if the `dev` script is prefixed with `sst dev`, remove the prefix. For example, for Next.js app, change the `dev` script from `sst dev next dev` to `next dev`.

---

### Global helper functions

Here are some helpers you can use in `sst.config.ts`:
- Name of app: `$app.name` (`app.name` in v2)
- Name of stage: `$app.stage` (`app.stage` in v2)
- Running in `sst dev` mode: `$dev === true` (`app.mode === "dev` in v2)
- Running in `sst deploy` mode: `$dev === false` (`app.mode === "deploy` in v2)
- Running in `sst remove` mode: You code is not executed. SST remove resources stored in the state file. (`app.mode === "remove` in v2)
- Region of stage: (`app.region` in v2)
  A big change in SST v3 is that resources can now be deployed to different stage, with the concept of AWS profiles. There is a default AWS profile. To get the region ⇒ `aws.getRegionOutput()`
- `addDefaultFunctionBinding`, `addDefaultFunctionEnv`, `addDefaultFunctionPermissions`, `setDefaultFunctionProps`
  ```ts title="sst.config.ts"
  $transform(sst.aws.Function, (args, opts) => {
    args.runtime = "nodejs18.x";
  })
  ```

---

## Migrate constructs to v3

v3 does not use CloudFormation. There is no concept of `Stacks`. All resources are defined in one place.

Constructs in v2 have their equivalent components in v3. We are will copy over our v2 constructs over to v3 components. The constructs can be treated in one of following 3 categories:
1. Transient constructs - do not contain data, like `Function`, `Topic`, and `Queue`.
1. Data constructs - contains application data, like `RDS`, `Table`, and `Bucket`.
1. Transient constructs with domains - has custom domain configured, like `Api`, `StaticSite`, and `NextjsSite`.

We will go over each type of constructs. But first, update the app structure to v3.

### Transient Constructs

Constructs like `Function`, `Cron`, `Topic`, `Queue`, and `KinesisStream` do not contain data. They can be recreated in the v3 app.

Refer to [Construct Reference](#construct-reference).

### Data Constructs

Constructs like `RDS`, `Table`, `Bucket`, and `Cognito` contains data. If you do not need to keep the data, you can recreate them similar to transicient constructs. This is often the case for non-production stages. For production stage, if you'd want to retain the data, you need to import the underlying AWS resources into v3 app.

For example, here are the steps for importing an S3 bucket named `app-prod-MyBucket`.

1. Import 
    
   Imagine the bucket is defined in SST v2 like this, and the bucket name is `app-prod-MyBucket`

   ```ts title="sst.config.ts"
   // SST v2
   const bucket = new Bucket(stack, "MyBucket");

   // SST v3
   const bucket = new sst.aws.Bucket("MyBucket", {
     transform: {
       bucket: (args, opts) => {
         args.bucket = "app-prod-MyBucket";
         opts.import = "app-prod-MyBucket";
       },
       cors: (args, opts) => {
         opts.import = "app-prod-MyBucket";
       },
       policy: (args, opts) => {
         opts.import = "app-prod-MyBucket";
       },
       publicAccessBlock: (args, opts) => {
         opts.import = "app-prod-MyBucket";
       }		
     }
   });
   ```
    
2. Deploy
    
   You will get an error if the resource configurations in your code do not match the exact configuration of the bucket in your AWS account.
   
   This is good. Because we don’t want to change the resources.
   
   In the error message, you will see the configurations that do not match. Add them to the corresponding `transform` block.
   
   Deploy again.
    
  :::note
  After the bucket is imported, the v2 app can still make changes to the resource. If you try to remove the v2 app or remove the bucket from the v2 app, the S3 bucket will still get removed. To prevent this, make sure to set the removal policy for the v2 app to `retain`.
  :::

### Constructs with Domains

Following constructs support custom domains:
- API constructs like `Api`, `ApiGatewayv1`, `AppSyncApi`, `WebSocketApi`;
- The `Service` construct;
- The `StaticSite` construct; and
- SSR constructs like `NextjsSite`, `SvelteKitSite`, `RemixSite`, `AstroSite`, and `SolidStartSite`

These constructs can be recreated. However, if custom domain is configured, they need to be recreate in v3 without custom domain first. And when ready to flip the domain, redeploy with the option to override the DNS record.

1. Create the resource in SST v3 without a custom domain
    
    ```tsx
    // SST v2
    new Nextjs(stack, "MySite", {
      customDomain: "domain.com"
    });
    
    // SST v3
    new Nextjs("MySite");
    ```
    
2. Deploy
3. Flip the domain
    
    ```tsx
    new Nextjs("MySite", {
    	domain: {
    		name: "domain.com",
    		dns: sst.aws.dns({ override: true }),
    	}
    });
    ```
    
    This will create the necessary resources to set up the domain and then override the DNS record to point the domain at the new URL.
    
:::note
After we overrid the Route 53 DNS record to point the domain to the new URL, the v2 app can still make changes to it. If you try to remove the v2 app or remove the site from the v2 app, the DNS record will still get removed. To prevent this, make sure to set the removal policy for the v2 app to `retain`.
:::

### Construct subscribers

Many constructs have subscribers. For example, `Queue` has consumer, `Bucket` has notification, `Table` have streams. If a construct is recreated in the v3 app, you can recreate its subscribers. But recreating subscribers for imported constructs, ie. data constructs, is not straight forward. For example:
- Recreating the consumer for an imported Queue will fail because a `Queue` can only have 1 consumer; and
- Recreating the consumer for an imported DynamoDB Table will result in double processing.

To get around the issue:
1. Deploy the v3 app without the subscribers. Either by commenting out the `.subscribe()` call, or return early in the subscriber function.
2. When ready to flip, remove the subscribers in the v2 app and deploy.
3. Add the subscribers to the v3 app and deploy.

This ensure that at any time, the same subscriber is only attached once to a resource.

---

## Clients

The Node.js client, now called the [JS SDK](/docs/reference/sdk/) has a couple of minor changes.

Update `sst` to the latest version in your `package.json`. If you have a monorepo, make sure to update `sst` in all your packages.

---

### Bind

In SST v3, you access all bound or _linked_ resources are accessed through the `Resource` module.

Say you link a bucket to a function.

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts" {5}
  const bucket = new sst.aws.Bucket("MyBucket");

  new sst.aws.Function("MyFunction", {
    handler: "src/lambda.handler",
    link: [bucket]
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts" {5}
  const bucket = new Bucket(stack, "MyBucket");

  new Function(stack, "MyFunction", {
    handler: "src/lambda.handler",
    bind: [bucket]
  });
  ```
  </TabItem>
</Tabs>

In your function you would access it like so.

<Tabs>
  <TabItem label="v3">
  ```ts title="src/lambda.ts" "Resource.MyBucket.name" "sst"
  import { Resource } from "sst";

  console.log(Resource.MyBucket.name);
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="src/lambda.ts" "Bucket.MyBucket.bucketName" "sst/node/bucket"
  import { Bucket } from "sst/node/bucket";

  console.log(Bucket.MyBucket.bucketName);
  ```
  </TabItem>
</Tabs>

---

### Config

The same applies to `Config` as well. Let's look at a secret.

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts" {5}
  const secret = new sst.Secret("MySecret");

  new sst.aws.Function("MyFunction", {
    handler: "src/lambda.handler",
    link: [secret]
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts" {5}
  const secret = new Config.Secret(stack, "MySecret");

  new Function(stack, "MyFunction", {
    handler: "src/lambda.handler",
    bind: [secret]
  });
  ```
  </TabItem>
</Tabs>

And in your function you access it in the same way.

<Tabs>
  <TabItem label="v3">
  ```ts title="src/lambda.ts" "Resource.MySecret.value" "sst"
  import { Resource } from "sst";

  console.log(Resource.MySecret.value);
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="src/lambda.ts" "Config.MySecret" "sst/node/config"
  import { Config } from "sst/node/config";

  console.log(Config.MySecret);
  ```
  </TabItem>
</Tabs>

---

## Constructs

Below shows the v3 component version of a v2 construct.

---

### Api

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const api = new sst.aws.ApiGatewayV2("MyApi", {
    domain: "api.example.com"
  });

  api.route("GET /", "src/get.handler");
  api.route("POST /", "src/post.handler");
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const api = new Api(stack, "MyApi", {
    customDomain: "api.example.com"
  });

  api.addRoutes(stack, {
    "GET /": "src/get.main",
    "POST /": "src/post.handler"
  });
  ```
  </TabItem>
</Tabs>

---

### RDS

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.Postgres("MyDatabase", {
    version: "15.5",
    databaseName: "acme"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new RDS(stack, "MyDatabase", {
    engine: "postgresql15.5",
    defaultDatabaseName: "acme",
    migrations: "path/to/migration/scripts"
  });
  ```
  </TabItem>
</Tabs>

For migrations, we recommend using [Drizzle Kit](https://orm.drizzle.team/kit-docs/overview). Check out our [Drizzle example](/docs/start/aws/drizzle/).

---

### Cron

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.Cron("MyCronJob", {
    schedule: "rate(1 minute)",
    job: "src/cron.handler"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new Cron(stack, "MyCronJob", {
    schedule: "rate(1 minute)",
    job: "src/cron.handler"
  });
  ```
  </TabItem>
</Tabs>

---

### Table

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const table = new sst.aws.Dynamo("MyTable", {
    fields: {
      id: "string"
    },
    primaryIndex: { hashKey: "id" }
  });

  table.subscribe("src/subscriber.handler");
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const table = new Table(stack, "MyTable", {
    fields: {
      id: "string"
    },
    primaryIndex: { partitionKey: "id" }
  });

  table.addConsumers(stack, {
    consumer: "src/subscriber.handler"
  });
  ```
  </TabItem>
</Tabs>

---

### Topic

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const topic = new sst.aws.SnsTopic("MyTopic");

  topic.subscribe("src/subscriber.handler");
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const topic = new Topic(stack, "MyTopic");

  topic.addSubscribers(stack, {
    subscriber: "src/subscriber.handler"
  });
  ```
  </TabItem>
</Tabs>

---

### Queue

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const queue = new sst.aws.Queue("MyQueue");

  queue.subscribe("src/subscriber.handler");
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const queue = new Queue(stack, "MyQueue");

  queue.addConsumer(stack, "src/subscriber.handler");
  ```
  </TabItem>
</Tabs>

---

### Config

The `Config` construct is now broken into a `Secret` component and v3 has a separate way to bind any value or _parameter_.

---

#### Secret

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const secret = new sst.Secret("MySecret");
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const secret = new Config.Secret(stack, "MySecret");
  ```
  </TabItem>
</Tabs>

---

#### Parameter

The `Linkable` component lets you bind or _link_ any value.

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const secret = new sst.Linkable("MyParameter", {
    properties: { version: "1.2.0" }
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const secret = new Config.Parameter(stack, "MyParameter", {
    value: "1.2.0"
  });
  ```
  </TabItem>
</Tabs>

In your function you'd access this using.

<Tabs>
  <TabItem label="v3">
  ```ts title="src/lambda.ts"
  import { Resource } from "sst";

  console.log(Resource.MyParameter.version);
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="src/lambda.ts"
  import { Config } from "sst/node/config";

  console.log(Config.MyParameter);
  ```
  </TabItem>
</Tabs>

---

### Bucket

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const bucket = new sst.aws.Bucket("MyBucket");

  bucket.subscribe("src/subscriber.handler");
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const bucket = new Bucket(stack, "MyBucket");

  bucket.addNotifications(stack, {
    notification: "src/notification.main"
  });
  ```
  </TabItem>
</Tabs>

---

### Service

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const cluster = new sst.aws.Cluster("MyCluster", {
    vpc: {
      id: "vpc-0d19d2b8ca2b268a1",
      securityGroups: ["sg-0399348378a4c256c"],
      publicSubnets: ["subnet-0b6a2b73896dc8c4c", "subnet-021389ebee680c2f0"],
      privateSubnets: ["subnet-0db7376a7ad4db5fd ", "subnet-06fc7ee8319b2c0ce"]
    }
  });

  cluster.addService("MyService", {
    public: {
      domain: "my-app.com",
      ports: [
        { listen: "80/http" }
      ]
    }
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new Service(stack, "MyService", {
    customDomain: "my-app.com",
    path: "./service",
    port: 80,
    cdk: {
      vpc: Vpc.fromLookup(stack, "VPC", {
        vpcId: "vpc-0d19d2b8ca2b268a1"
      })
    }
  });
  ```
  </TabItem>
</Tabs>

---

### Cognito

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const userPool = new sst.aws.CognitoUserPool("MyUserPool");

  const client = userPool.addClient("MyClient");

  new sst.aws.CognitoIdentityPool("MyIdentityPool", {
    userPools: [{
      userPool: userPool.id,
      client: client.id
    }]
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new Cognito(stack, "MyAuth");
  ```
  </TabItem>
</Tabs>

---

### Function

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.Function("MyFunction", {
    handler: "src/lambda.handler"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new Function(stack, "MyFunction", {
    handler: "src/lambda.handler"
  });
  ```
  </TabItem>
</Tabs>

---

### AstroSite
<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.Astro("MyWeb", {
    domain: "my-app.com"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new AstroSite(stack, "MyWeb", {
    customDomain: "my-app.com"
  });
  ```
  </TabItem>
</Tabs>

---

### StaticSite

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.StaticSite("MyWeb", {
    domain: "my-app.com"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new StaticSite(stack, "MyWeb", {
    customDomain: "my-app.com"
  });
  ```
  </TabItem>
</Tabs>

---

### RemixSite

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.Remix("MyWeb", {
    domain: "my-app.com"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new RemixSite(stack, "MyWeb", {
    customDomain: "my-app.com"
  });
  ```
  </TabItem>
</Tabs>

---

### NextjsSite

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.Nextjs("MyWeb", {
    domain: "my-app.com"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new NextjsSite(stack, "MyWeb", {
    customDomain: "my-app.com"
  });
  ```
  </TabItem>
</Tabs>

---

### AppSyncApi

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const api = new sst.aws.AppSync("MyApi", {
    schema: "schema.graphql",
    domain: "api.domain.com"
  });

  const lambdaDS = api.addDataSource({
    name: "lambdaDS",
    lambda: "src/lambda.handler"
  });
  api.addResolver("Query user", {
    dataSource: lambdaDS.name
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const api = new AppSyncApi(stack, "MyApi", {
    schema: "graphql/schema.graphql",
    customDomain: "api.example.com"
  });

  api.addDataSources(stack, {
    lambdaDS: "src/lambda.handler"
  });
  api.addResolvers(stack, {
    "Query user": "lambdaDS"
  });
  ```
  </TabItem>
</Tabs>

---

### SvelteKitSite

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.SvelteKit("MyWeb", {
    domain: "my-app.com"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new SvelteKitSite(stack, "MyWeb", {
    customDomain: "my-app.com"
  });
  ```
  </TabItem>
</Tabs>

---

### SolidStartSite

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  new sst.aws.SolidStart("MyWeb", {
    domain: "my-app.com"
  });
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  new SolidStartSite(stack, "MyWeb", {
    customDomain: "my-app.com"
  });
  ```
  </TabItem>
</Tabs>

---

### WebSocketApi

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const api = new sst.aws.ApiGatewayWebSocket("MyApi", {
    domain: "api.example.com"
  });

  api.route("$connect", "src/connect.handler");
  api.route("$disconnect", "src/disconnect.handler");
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const api = new WebSocketApi(stack, "MyApi", {
    customDomain: "api.example.com"
  });

  api.addRoutes(stack, {
    $connect: "src/connect.handler",
    $disconnect: "src/disconnect.handler"
  });
  ```
  </TabItem>
</Tabs>

---

### KinesisStream

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const stream = new sst.aws.KinesisStream("MyStream");

  stream.subscribe("src/subscriber.handler");
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const stream = new KinesisStream(stack, "MyStream");

  stream.addConsumers(stack, {
    consumer: "src/subscriber.handler"
  });
  ```
  </TabItem>
</Tabs>

---

### ApiGatewayV1Api

<Tabs>
  <TabItem label="v3">
  ```ts title="sst.config.ts"
  const api = new sst.aws.ApiGatewayV1("MyApi", {
    domain: "api.example.com"
  });

  api.route("GET /", "src/get.handler");
  api.route("POST /", "src/post.handler");
  api.deploy();
  ```
  </TabItem>
  <TabItem label="v2">
  ```ts title="sst.config.ts"
  const api = new ApiGatewayV1Api(stack, "MyApi", {
    customDomain: "api.example.com"
  });

  api.addRoutes(stack, {
    "GET /": "src/get.handler",
    "POST /": "src/post.handler"
  });
  ```
  </TabItem>
</Tabs>
