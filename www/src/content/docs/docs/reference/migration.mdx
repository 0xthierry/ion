---
title: Migration
description: Migration guide to SST v3.
---

This guide will help you migrate from SST v2 to v3. Treat these are recommendations. The exact migration plan will be different from team to team depending on the resources in your app, and sensitivity of down time.

:::note
If you are using the `Job`, `Auth`, `EventBus`, `Script`, `RDS` with MySQL engine, or `Function` with non-Node.js runtime in your SST v2 app, do not migrate yet. These constructs will be supported in v3 soon.
:::

---

## Before You Begin

1. Set the removal policy to `retain` in the v2 app for production stages. This ensures resources don't get accidentally removed.
1. Make code changes in a new branch.

---

### Initialize v3 App

1. Run `npm update sst` to update SST to v3
2. Run `npx sst version` to ensure v3 is installed
3. Run `mv sst.config.ts sst.config.ts.bk` to backup the config
4. Run `npx sst init` to initialize an v3 app. Make sure to use the same app name.
5. Configure removal policy.

    Similar to `setDefaultRemovalPolicy` in v2, you can configure the removal policy in `sst.config.ts` in v3. By default, v3 has removal policy set to `retain` for the `production` stage, and `remove` for other stages.
    ```ts title="sst.config.ts"
    app(input) {
      return {
        name: "playground",
        removal: input?.stage === "production" ? "retain" : "remove",
      };
    },
    ```
6. Run `npx sst deploy` to deploy an empty app to ensure the app is configured correctly.
7. In your root `package.json`, and that in your monorepo packages, if the `dev` script is prefixed with `sst dev`, remove the prefix. For example, for Next.js app, change the `dev` script from `sst dev next dev` to `next dev`.

---

### Global helper functions

Here are some helpers you can use in `sst.config.ts`:
- Name of app: `$app.name` (`app.name` in v2)
- Name of stage: `$app.stage` (`app.stage` in v2)
- Running in `sst dev` mode: `$dev === true` (`app.mode === "dev` in v2)
- Running in `sst deploy` mode: `$dev === false` (`app.mode === "deploy` in v2)
- Running in `sst remove` mode: You code is not executed. SST remove resources stored in the state file. (`app.mode === "remove` in v2)
- Region of stage: (`app.region` in v2)
  A big change in SST v3 is that resources can now be deployed to different stage, with the concept of AWS profiles. There is a default AWS profile. To get the region ⇒ `aws.getRegionOutput()`
- `addDefaultFunctionBinding`, `addDefaultFunctionEnv`, `addDefaultFunctionPermissions`, `setDefaultFunctionProps`
  ```ts title="sst.config.ts"
  $transform(sst.aws.Function, (args, opts) => {
    args.runtime = "nodejs18.x";
  })
  ```

---

## Migrate constructs to v3

v3 does not use CloudFormation. There is no concept of `Stacks`. All resources are defined in one place.

Constructs in v2 have their equivalent components in v3. We are will copy over our v2 constructs over to v3 components. The constructs can be treated in one of following 3 categories:
1. Transient constructs - do not contain data, like `Function`, `Topic`, and `Queue`.
1. Data constructs - contains application data, like `RDS`, `Table`, and `Bucket`.
1. Transient constructs with domains - has custom domain configured, like `Api`, `StaticSite`, and `NextjsSite`.

We will go over each type of constructs. But first, update the app structure to v3.

### Transient Constructs

Constructs like `Function`, `Cron`, `Topic`, `Queue`, and `KinesisStream` do not contain data. They can be recreated in the v3 app.

Refer to [Construct Reference](#construct-reference).

### Data Constructs

Constructs like `RDS`, `Table`, `Bucket`, and `Cognito` contains data. If you do not need to keep the data, you can recreate them similar to transicient constructs. This is often the case for non-production stages. For production stage, if you'd want to retain the data, you need to import the underlying AWS resources into v3 app.

For example, here are the steps for importing an S3 bucket named `app-prod-MyBucket`.

1. Import 
    
   Imagine the bucket is defined in SST v2 like this, and the bucket name is `app-prod-MyBucket`

   ```ts title="sst.config.ts"
   // SST v2
   const bucket = new Bucket(stack, "MyBucket");

   // SST v3
   const bucket = new sst.aws.Bucket("MyBucket", {
     transform: {
       bucket: (args, opts) => {
         args.bucket = "app-prod-MyBucket";
         opts.import = "app-prod-MyBucket";
       },
       cors: (args, opts) => {
         opts.import = "app-prod-MyBucket";
       },
       policy: (args, opts) => {
         opts.import = "app-prod-MyBucket";
       },
       publicAccessBlock: (args, opts) => {
         opts.import = "app-prod-MyBucket";
       }		
     }
   });
   ```
    
2. Deploy
    
   You will get an error if the resource configurations in your code do not match the exact configuration of the bucket in your AWS account.
   
   This is good. Because we don’t want to change the resources.
   
   In the error message, you will see the configurations that do not match. Add them to the corresponding `transform` block.
   
   Deploy again.
    
  :::note
  After the bucket is imported, the v2 app can still make changes to the resource. If you try to remove the v2 app or remove the bucket from the v2 app, the S3 bucket will still get removed. To prevent this, make sure to set the removal policy for the v2 app to `retain`.
  :::

### Constructs with Domains

Following constructs support custom domains:
- API constructs like `Api`, `ApiGatewayv1`, `AppSyncApi`, `WebSocketApi`;
- The `Service` construct;
- The `StaticSite` construct; and
- SSR constructs like `NextjsSite`, `SvelteKitSite`, `RemixSite`, `AstroSite`, and `SolidStartSite`

These constructs can be recreated. However, if custom domain is configured, they need to be recreate in v3 without custom domain first. And when ready to flip the domain, redeploy with the option to override the DNS record.

1. Create the resource in SST v3 without a custom domain
    
    ```tsx
    // SST v2
    new Nextjs(stack, "MySite", {
      customDomain: "domain.com"
    });
    
    // SST v3
    new Nextjs("MySite");
    ```
    
2. Deploy
3. Flip the domain
    
    ```tsx
    new Nextjs("MySite", {
    	domain: {
    		name: "domain.com",
    		dns: sst.aws.dns({ override: true }),
    	}
    });
    ```
    
    This will create the necessary resources to set up the domain and then override the DNS record to point the domain at the new URL.
    
:::note
After we overrid the Route 53 DNS record to point the domain to the new URL, the v2 app can still make changes to it. If you try to remove the v2 app or remove the site from the v2 app, the DNS record will still get removed. To prevent this, make sure to set the removal policy for the v2 app to `retain`.
:::

### Construct subscribers

Many constructs have subscribers. For example, `Queue` has consumer, `Bucket` has notification, `Table` have streams. If a construct is recreated in the v3 app, you can recreate its subscribers. But recreating subscribers for imported constructs, ie. data constructs, is not straight forward. For example:
- Recreating the consumer for an imported Queue will fail because a `Queue` can only have 1 consumer; and
- Recreating the consumer for an imported DynamoDB Table will result in double processing.

To get around the issue:
1. Deploy the v3 app without the subscribers. Either by commenting out the `.subscribe()` call, or return early in the subscriber function.
2. When ready to flip, remove the subscribers in the v2 app and deploy.
3. Add the subscribers to the v3 app and deploy.

This ensure that at any time, the same subscriber is only attached once to a resource.

## Update Application Code to v3

Update `sst` to the latest version in your `package.json`. If you have a monorepo, make sure to update `sst` in all packages.

In SST v3, you access all linked resources through the `Resource` module. Here is an example for accessing linked secrets.

```ts title="lambda.ts"
// SST v2
import { Bucket } from "sst/node/config";
console.log(Config.STRIPE_KEY);

// SST v3
import { Resource } from "sst";
console.log(Bucket.STRIPE_KEY.value);
```

And here is an example for accessing the linked bucket.

```ts title="lambda.ts"
// SST v2
import { Bucket } from "sst/node/bucket";
console.log(Bucket.MyBucket.bucketName);

// SST v3
import { Resource } from "sst";
console.log(Bucket.MyBucket.name);
```

---

## Construct Reference

This section shows the equivalent v3 component for each supported v2 construct.

### Function
```ts title="sst.config.ts"
// v2
new Function(stack, "MyFunction", {
  handler: "src/lambda.handler",
  bind: [bucket],
});

// v3
new sst.aws.Function("MyFunction", {
  handler: "src/lambda.handler"
  link: [bucket],
});
```

### Cron
```ts title="sst.config.ts"
// v2
new Cron(stack, "MyCronJob", {
  schedule: "rate(1 minute)",
  job: "src/cron.handler",
});

// v3
new sst.aws.Cron("MyCronJob", {
  schedule: "rate(1 minute)"
  job: "src/cron.handler",
});
```

### Topic
```ts title="sst.config.ts"
// v2
const topic = new Topic(stack, "MyTopic");
topic.addSubscribers(stack, {
  subscriber: "src/subscriber.handler",
});

// v3
const topic = new sst.aws.SnsTopic("MyTopic");
topic.subscribe("src/subscriber.handler");
```

### Queue
```ts title="sst.config.ts"
// v2
const queue = new Queue(stack, "MyQueue");
queue.addConsumer(stack, "src/subscriber.handler");

// v3
const queue = new sst.aws.Queue("MyQueue");
queue.subscribe("src/subscriber.handler");
```

### KinesisStream
```ts title="sst.config.ts"
// v2
const stream = new KinesisStream(stack, "MyStream");
stream.addConsumers(stack, {
  consumer: "src/subscriber.handler",
});

// v3
const stream = new sst.aws.KinesisStream("MyStream");
stream.subscribe("src/subscriber.handler");
```

### RDS
```ts title="sst.config.ts"
// v2
new RDS(stack, "MyDatabase", {
  engine: "postgresql15.5",
  defaultDatabaseName: "acme",
  migrations: "path/to/migration/scripts",
});

// v3
new sst.aws.Postgres("MyDatabase", {
  version: "15.5",
  databaseName: "acme",
});
```

TODO: how to run migrations in v3

### Table
```ts title="sst.config.ts"
// v2
const table = new Table(stack, "MyTable", {
  fields: {
    id: "string",
  },
  primaryIndex: { partitionKey: "id" },
});
table.addConsumers(stack, {
  consumer: "src/subscriber.handler",
});

// v3
const table = new sst.aws.Dynamo("MyTable", {
  fields: {
    id: "string",
  },
  primaryIndex: { hashKey: "id" }
});
table.subscribe("src/subscriber.handler");
```

### Bucket
```ts title="sst.config.ts"
// v2
const bucket = new Bucket(stack, "MyBucket");
bucket.addNotifications(stack, {
  notification: "src/notification.main",
});

// v3
const bucket = new sst.aws.Bucket("MyBucket");
bucket.subscribe("src/subscriber.handler");
```

### Cognito
```ts title="sst.config.ts"
// v2
new Cognito(stack, "Auth");

// v3
const userPool = new sst.aws.CognitoUserPool("MyUserPool");
const client = userPool.addClient("MyClient");
new sst.aws.CognitoIdentityPool("MyIdentityPool", {
  userPools: [{
    userPool: userPool.id,
    client: client.id,
  }]
});
```

### Api
```ts title="sst.config.ts"
// v2
const api = new Api(stack, "MyApi", {
  customDomain: "api.example.com",
});
api.addRoutes(stack, {
  "GET /": "src/get.main",
  "POST /": "src/post.handler",
});

// v3
const api = new sst.aws.ApiGatewayV2("MyApi", {
  domain: "api.example.com"
});
api.route("GET /", "src/get.handler");
api.route("POST /", "src/post.handler");
```

### ApiGatewayV1Api
```ts title="sst.config.ts"
// v2
const api = new ApiGatewayV1Api(stack, "MyApi", {
  customDomain: "api.example.com",
});
api.addRoutes(stack, {
  "GET /": "src/get.handler",
  "POST /": "src/post.handler",
});

// v3
const api = new sst.aws.ApiGatewayV1("MyApi", {
  domain: "api.example.com"
});
api.route("GET /", "src/get.handler");
api.route("POST /", "src/post.handler");
api.deploy();
```

### AppSyncApi
```ts title="sst.config.ts"
// v2
const api = new AppSyncApi(stack, "MyApi", {
  schema: "graphql/schema.graphql",
  customDomain: "api.example.com",
});
api.addDataSources(stack, {
  lambdaDS: "src/lambda.handler",
});
api.addResolvers(stack, {
  "Query user": "lambdaDS",
});

// v3
const api = new sst.aws.AppSync("MyApi", {
  schema: "schema.graphql",
  domain: "api.domain.com",
});
const lambdaDS = api.addDataSource({
  name: "lambdaDS",
  lambda: "src/lambda.handler",
});
api.addResolver("Query user", {
  dataSource: lambdaDS.name,
});
```

### WebSocketApi
```ts title="sst.config.ts"
// v2
const api = new WebSocketApi(stack, "MyApi", {
  customDomain: "api.example.com",
});
api.addRoutes(stack, {
  $connect: "src/connect.handler",
  $disconnect: "src/disconnect.handler",
});

// v3
const api = new sst.aws.ApiGatewayWebSocket("MyApi", {
  domain: "api.example.com"
});
api.route("$connect", "src/connect.handler");
api.route("$disconnect", "src/disconnect.handler");
```

### Service
```ts title="sst.config.ts"
// v2
new Service(stack, "MyService", {
  customDomain: "my-app.com",
  path: "./service",
  port: 80,
  cdk: {
    vpc: Vpc.fromLookup(stack, "VPC", {
      vpcId: "vpc-0d19d2b8ca2b268a1",
    }),
  },
});

// v3
const cluster = new sst.aws.Cluster("MyCluster", {
  vpc: {
    id: "vpc-0d19d2b8ca2b268a1",
    publicSubnets: ["subnet-0b6a2b73896dc8c4c", "subnet-021389ebee680c2f0"],
    privateSubnets: ["subnet-0db7376a7ad4db5fd ", "subnet-06fc7ee8319b2c0ce"],
    securityGroups: ["sg-0399348378a4c256c"],
  }
});
cluster.addService("MyService", {
  public: {
    domain: "my-app.com",
    ports: [
      { listen: "80/http" },
    ]
  }
});
```

### StaticSite
```ts title="sst.config.ts"
// v2
new StaticSite(stack, "MyWeb", {
  customDomain: "my-app.com",
});

// v3
new sst.aws.StaticSite("MyWeb", {
  domain: "my-app.com"
});
```

### NextjsSite
```ts title="sst.config.ts"
// v2
new NextjsSite(stack, "MyWeb", {
  customDomain: "my-app.com",
  bind: [bucket],
});

// v3
new sst.aws.Nextjs("MyWeb", {
  domain: "my-app.com"
  link: [bucket],
});
```

### SvelteKitSite
```ts title="sst.config.ts"
// v2
new SvelteKitSite(stack, "MyWeb", {
  customDomain: "my-app.com",
});

// v3
new sst.aws.SvelteKit("MyWeb", {
  domain: "my-app.com"
});
```

### RemixSite
```ts title="sst.config.ts"
// v2
new RemixSite(stack, "MyWeb", {
  customDomain: "my-app.com",
});

// v3
new sst.aws.Remix("MyWeb", {
  domain: "my-app.com"
});
```

### AstroSite
```ts title="sst.config.ts"
// v2
new AstroSite(stack, "MyWeb", {
  customDomain: "my-app.com",
});

// v3
new sst.aws.Astro("MyWeb", {
  domain: "my-app.com"
});
```

### SolidStartSite
```ts title="sst.config.ts"
// v2
new SolidStartSite(stack, "MyWeb", {
  customDomain: "my-app.com",
});

// v3
new sst.aws.SolidStart("MyWeb", {
  domain: "my-app.com"
});
```